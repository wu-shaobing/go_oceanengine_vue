---
globs: ["**/*.tsx", "**/*.jsx"]
---

# React 组件规范

## 组件文件结构

```typescript
// UserProfile.tsx

// 1. 类型导入（React 相关）
import type { FC, ReactNode } from 'react';

// 2. React Hooks 导入
import { useState, useEffect, useMemo, useCallback } from 'react';

// 3. 第三方库导入
import { useRouter } from 'next/router';
import classNames from 'classnames';

// 4. 项目内部导入
import { Button } from '@/components/ui';
import { getUserApi } from '@/services/user';
import type { User } from '@/types/user.types';

// 5. 样式导入
import styles from './UserProfile.module.css';

// 6. 类型定义
interface UserProfileProps {
  userId: string;
  onUpdate?: (user: User) => void;
  className?: string;
  children?: ReactNode;
}

// 7. 组件定义
export const UserProfile: FC<UserProfileProps> = ({
  userId,
  onUpdate,
  className,
  children,
}) => {
  // State 定义
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Hooks 调用
  const router = useRouter();
  
  // 副作用
  useEffect(() => {
    loadUser();
  }, [userId]);
  
  // 事件处理函数
  const loadUser = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const data = await getUserApi(userId);
      setUser(data);
      onUpdate?.(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : '加载失败');
    } finally {
      setLoading(false);
    }
  };
  
  const handleEdit = useCallback(() => {
    router.push(`/users/${userId}/edit`);
  }, [userId, router]);
  
  // 计算值
  const displayName = useMemo(() => {
    return user?.name || '未知用户';
  }, [user]);
  
  // 条件渲染
  if (loading) {
    return <div className={styles.loading}>加载中...</div>;
  }
  
  if (error) {
    return <div className={styles.error}>{error}</div>;
  }
  
  if (!user) {
    return <div className={styles.empty}>未找到用户</div>;
  }
  
  // 主渲染
  return (
    <div className={classNames(styles.container, className)}>
      <div className={styles.header}>
        <h2>{displayName}</h2>
        <Button onClick={handleEdit}>编辑</Button>
      </div>
      <div className={styles.content}>
        <p>邮箱: {user.email}</p>
        {children}
      </div>
    </div>
  );
};

// 8. 默认导出（可选）
export default UserProfile;
```

## Props 定义规范

### 基础 Props

```typescript
// ✅ 正确：明确的 Props 类型
interface ButtonProps {
  /** 按钮文本 */
  children: ReactNode;
  /** 按钮类型 */
  variant?: 'primary' | 'secondary' | 'danger';
  /** 是否禁用 */
  disabled?: boolean;
  /** 点击事件 */
  onClick?: () => void;
  /** 自定义类名 */
  className?: string;
}

export const Button: FC<ButtonProps> = ({
  children,
  variant = 'primary',
  disabled = false,
  onClick,
  className,
}) => {
  return (
    <button
      className={classNames(styles.button, styles[variant], className)}
      disabled={disabled}
      onClick={onClick}
    >
      {children}
    </button>
  );
};
```

### 泛型 Props

```typescript
// ✅ 正确：泛型组件
interface ListProps<T> {
  items: T[];
  renderItem: (item: T, index: number) => ReactNode;
  keyExtractor: (item: T) => string;
  emptyText?: string;
}

export function List<T>({
  items,
  renderItem,
  keyExtractor,
  emptyText = '暂无数据',
}: ListProps<T>) {
  if (items.length === 0) {
    return <div className={styles.empty}>{emptyText}</div>;
  }
  
  return (
    <div className={styles.list}>
      {items.map((item, index) => (
        <div key={keyExtractor(item)} className={styles.item}>
          {renderItem(item, index)}
        </div>
      ))}
    </div>
  );
}

// 使用
<List<User>
  items={users}
  renderItem={(user) => <UserCard user={user} />}
  keyExtractor={(user) => user.id}
/>
```

## Hooks 使用规范

### useState

```typescript
// ✅ 正确：明确类型
const [user, setUser] = useState<User | null>(null);
const [count, setCount] = useState<number>(0);
const [items, setItems] = useState<string[]>([]);

// ✅ 正确：函数式更新
setCount(prev => prev + 1);
setItems(prev => [...prev, 'new item']);

// ❌ 错误：直接修改状态
items.push('new item'); // 不要这样做
```

### useEffect

```typescript
// ✅ 正确：明确依赖项
useEffect(() => {
  fetchData();
}, [userId]); // 依赖 userId

// ✅ 正确：清理函数
useEffect(() => {
  const timer = setTimeout(() => {
    console.log('Delayed');
  }, 1000);
  
  return () => {
    clearTimeout(timer);
  };
}, []);

// ❌ 错误：缺少依赖项
useEffect(() => {
  fetchData(userId); // userId 应该在依赖数组中
}, []);
```

### useMemo

```typescript
// ✅ 正确：缓存计算结果
const sortedUsers = useMemo(() => {
  return users.sort((a, b) => a.name.localeCompare(b.name));
}, [users]);

const expensiveValue = useMemo(() => {
  return computeExpensiveValue(a, b);
}, [a, b]);

// ❌ 错误：不必要的 useMemo
const sum = useMemo(() => a + b, [a, b]); // 简单计算不需要
```

### useCallback

```typescript
// ✅ 正确：缓存回调函数
const handleClick = useCallback(() => {
  onClick(id);
}, [id, onClick]);

const handleSubmit = useCallback(async (data: FormData) => {
  try {
    await submitForm(data);
  } catch (error) {
    console.error(error);
  }
}, []);

// ❌ 错误：不必要的 useCallback
const handleClick = useCallback(() => {
  console.log('clicked'); // 没有依赖，不需要 useCallback
}, []);
```

### 自定义 Hooks

```typescript
// ✅ 正确：自定义 Hook
function useUser(userId: string) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  useEffect(() => {
    let cancelled = false;
    
    async function fetchUser() {
      setLoading(true);
      try {
        const data = await getUserApi(userId);
        if (!cancelled) {
          setUser(data);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err as Error);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    }
    
    fetchUser();
    
    return () => {
      cancelled = true;
    };
  }, [userId]);
  
  return { user, loading, error };
}

// 使用
function UserProfile({ userId }: Props) {
  const { user, loading, error } = useUser(userId);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  if (!user) return <div>Not found</div>;
  
  return <div>{user.name}</div>;
}
```

## 性能优化

### React.memo

```typescript
// ✅ 正确：使用 memo 避免不必要的重渲染
interface UserCardProps {
  user: User;
  onSelect: (id: string) => void;
}

export const UserCard = React.memo<UserCardProps>(({ user, onSelect }) => {
  return (
    <div onClick={() => onSelect(user.id)}>
      <h3>{user.name}</h3>
      <p>{user.email}</p>
    </div>
  );
});

UserCard.displayName = 'UserCard';

// ✅ 正确：自定义比较函数
export const UserCard = React.memo<UserCardProps>(
  ({ user, onSelect }) => {
    return <div>...</div>;
  },
  (prevProps, nextProps) => {
    return prevProps.user.id === nextProps.user.id;
  }
);
```

### 列表渲染优化

```typescript
// ✅ 正确：使用稳定的 key
function UserList({ users }: Props) {
  return (
    <div>
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
}

// ❌ 错误：使用 index 作为 key（数据会变化时）
{users.map((user, index) => (
  <UserCard key={index} user={user} />
))}
```

## 条件渲染

```typescript
// ✅ 正确：清晰的条件渲染
function UserProfile({ userId }: Props) {
  const { user, loading, error } = useUser(userId);
  
  // 提前返回
  if (loading) {
    return <LoadingSpinner />;
  }
  
  if (error) {
    return <ErrorMessage error={error} />;
  }
  
  if (!user) {
    return <EmptyState message="用户不存在" />;
  }
  
  return <UserDetails user={user} />;
}

// ✅ 正确：使用 && 运算符
{user && <UserCard user={user} />}
{isAdmin && <AdminPanel />}

// ✅ 正确：使用三元运算符
{loading ? <Spinner /> : <Content />}

// ❌ 错误：复杂的内联条件
{loading ? (
  <div>
    <Spinner />
    <p>Loading...</p>
  </div>
) : error ? (
  <div>
    <Icon name="error" />
    <p>Error: {error.message}</p>
  </div>
) : (
  <Content />
)}

// ✅ 正确：提取为独立组件
{renderContent()}
```

## 事件处理

```typescript
// ✅ 正确：事件处理器命名
const handleClick = () => {};
const handleSubmit = () => {};
const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {};

// ✅ 正确：防止默认行为
const handleSubmit = (e: React.FormEvent) => {
  e.preventDefault();
  // 处理提交
};

// ✅ 正确：避免内联箭头函数（频繁渲染时）
// ❌ 每次渲染都创建新函数
{users.map(user => (
  <button key={user.id} onClick={() => handleDelete(user.id)}>
    删除
  </button>
))}

// ✅ 使用 data 属性
{users.map(user => (
  <button key={user.id} data-id={user.id} onClick={handleDelete}>
    删除
  </button>
))}

const handleDelete = (e: React.MouseEvent<HTMLButtonElement>) => {
  const userId = e.currentTarget.dataset.id;
  deleteUser(userId);
};
```

## 样式处理

### CSS Modules

```typescript
// ✅ 正确：CSS Modules
import styles from './Button.module.css';

export const Button: FC<Props> = ({ variant, className }) => {
  return (
    <button
      className={classNames(
        styles.button,
        styles[variant],
        className
      )}
    >
      Click me
    </button>
  );
};
```

### 条件样式

```typescript
// ✅ 正确：使用 classNames 库
import classNames from 'classnames';

<div
  className={classNames(
    styles.card,
    {
      [styles.active]: isActive,
      [styles.disabled]: isDisabled,
    },
    className
  )}
/>

// ✅ 正确：模板字符串（简单场景）
<div className={`${styles.card} ${isActive ? styles.active : ''}`} />
```

## 强制行为

- 组件必须有明确的 Props 类型定义
- Props 接口必须导出（供外部使用）
- 使用函数组件 + Hooks，不使用类组件
- 复杂逻辑提取到自定义 Hook
- 组件文件以 PascalCase 命名
- 使用 CSS Modules 或 styled-components

## 禁止行为

- ❌ 不要在组件内定义组件
- ❌ 不要在 JSX 中写复杂逻辑
- ❌ 不要直接修改 props
- ❌ 不要在循环中使用 index 作为 key（数据会变化时）
- ❌ 避免过深的组件嵌套（最多 3-4 层）
- ❌ 不要忘记清理 useEffect 的副作用
- ❌ 不要过度使用 useMemo 和 useCallback（简单场景不需要）

## 质量检查清单

- [ ] Props 类型完整定义
- [ ] 所有 useEffect 都有正确的依赖项
- [ ] 复杂计算使用 useMemo
- [ ] 传递给子组件的回调使用 useCallback
- [ ] 列表渲染使用稳定的 key
- [ ] 有副作用的 useEffect 有清理函数
- [ ] 条件渲染清晰易读
- [ ] 事件处理器命名规范
- [ ] 样式处理合理（CSS Modules 或 styled-components）
