# 角色权限模块 (RBAC)

## 1. RBAC 模型概述

```
┌──────────────┐
│     User     │
│   (用户)     │
└──────┬───────┘
       │ N:1
       ▼
┌──────────────┐         ┌──────────────┐
│     Role     │────────▶│   DataScope  │
│   (角色)     │   has   │  (数据权限)   │
└──────┬───────┘         └──────────────┘
       │ N:M
       ▼
┌──────────────┐
│     Menu     │
│ (菜单/权限)  │
└──────────────┘
```

## 2. 数据模型

### 2.1 角色表 (sys_role)

```go
// backend/internal/app/admin/model/user.go
type Role struct {
    ID        uint64         `gorm:"primaryKey" json:"id"`
    Name      string         `gorm:"size:64;not null" json:"name"`      // 角色名称
    Key       string         `gorm:"size:64;uniqueIndex" json:"key"`    // 角色标识 (对应 DTO 中的 Code 字段)
    Sort      int            `gorm:"default:0" json:"sort"`             // 排序
    Status    int8           `gorm:"default:1;index" json:"status"`     // 状态
    DataScope int8           `gorm:"default:1" json:"data_scope"`       // 数据权限范围
    Remark    string         `gorm:"size:500" json:"remark"`
    CreatedAt time.Time      `json:"created_at"`
    UpdatedAt time.Time      `json:"updated_at"`
    DeletedAt gorm.DeletedAt `gorm:"index" json:"-"`
    CreatedBy uint64         `gorm:"default:0" json:"created_by"`
    UpdatedBy uint64         `gorm:"default:0" json:"updated_by"`

    // 关联菜单
    Menus []*Menu `gorm:"many2many:sys_role_menu" json:"menus,omitempty"`
}
```

> **注意**: DTO 字段名 `Code` 对应数据库 `key` 列；当前 `RoleCreateReq` 不包含 `DataScope`，角色数据权限默认为 1（全部）。
```

### 2.2 角色菜单关联表 (sys_role_menu)

```go
type RoleMenu struct {
    ID     uint64 `gorm:"primaryKey"`
    RoleID uint64 `gorm:"index;not null"`
    MenuID uint64 `gorm:"index;not null"`
}
```

### 2.3 数据权限范围 (DataScope)

| 值 | 含义 | 说明 |
|----|------|------|
| 1 | 全部数据 | 可查看所有数据 |
| 2 | 自定义 | 根据配置查看 |
| 3 | 本部门 | 仅本部门数据 |
| 4 | 本部门及以下 | 本部门及下级部门 |
| 5 | 仅本人 | 只能查看自己的数据 |

## 3. 服务层实现

### 3.1 创建角色

```go
// backend/internal/app/admin/service/role.go
func (s *RoleService) Create(ctx context.Context, req *dto.RoleCreateReq, operatorID uint64) error {
    // 1. 检查角色 Key 是否已存在
    var count int64
    s.db.Model(&model.Role{}).Where("`key` = ?", req.Code).Count(&count)
    if count > 0 {
        return errcode.New(errcode.ErrRoleExists)
    }

    // 2. 创建角色 (注意: DataScope 未从 req 读取，默认为 0)
    role := &model.Role{
        Name:      req.Name,
        Key:       req.Code,
        Status:    req.Status,
        Sort:      req.Sort,
        Remark:    req.Remark,
        CreatedBy: operatorID,
        UpdatedBy: operatorID,
    }

    return s.db.Create(role).Error
}
```

> **待优化**: 当前 `RoleCreateReq` DTO 不包含 `DataScope` 字段，角色创建时使用默认值；如需支持创建时指定数据权限，需在 DTO 和服务层同时添加该字段。

### 3.2 删除角色 (级联处理)

```go
func (s *RoleService) Delete(ctx context.Context, id uint64) error {
    // 1. 检查是否有用户使用该角色
    var userCount int64
    s.db.Model(&model.User{}).Where("role_id = ?", id).Count(&userCount)
    if userCount > 0 {
        return errcode.New(errcode.ErrRoleInUse)
    }

    // 2. 删除角色菜单关联
    s.db.Where("role_id = ?", id).Delete(&model.RoleMenu{})

    // 3. 删除角色
    return s.db.Delete(&model.Role{}, id).Error
}
```

### 3.3 分配角色菜单

```go
func (s *RoleService) UpdateRoleMenus(ctx context.Context, roleID uint64, menuIDs []uint64) error {
    // 1. 检查角色是否存在
    var role model.Role
    if err := s.db.First(&role, roleID).Error; err != nil {
        return errcode.New(errcode.ErrRoleNotFound)
    }

    // 2. 使用事务更新
    return s.db.Transaction(func(tx *gorm.DB) error {
        // 删除原有关联
        tx.Where("role_id = ?", roleID).Delete(&model.RoleMenu{})

        // 创建新关联
        if len(menuIDs) > 0 {
            roleMenus := make([]*model.RoleMenu, len(menuIDs))
            for i, menuID := range menuIDs {
                roleMenus[i] = &model.RoleMenu{
                    RoleID: roleID,
                    MenuID: menuID,
                }
            }
            tx.Create(&roleMenus)
        }
        return nil
    })
}
```

### 3.4 获取角色菜单

```go
func (s *RoleService) GetRoleMenus(ctx context.Context, roleID uint64) ([]uint64, error) {
    var roleMenus []model.RoleMenu
    s.db.Where("role_id = ?", roleID).Find(&roleMenus)

    menuIDs := make([]uint64, len(roleMenus))
    for i, rm := range roleMenus {
        menuIDs[i] = rm.MenuID
    }
    return menuIDs, nil
}
```

## 4. API 接口

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/api/v1/system/roles` | 角色列表 (分页) |
| GET | `/api/v1/system/roles/all` | 所有角色 (不分页) |
| POST | `/api/v1/system/roles` | 创建角色 |
| GET | `/api/v1/system/roles/:id` | 角色详情 |
| PUT | `/api/v1/system/roles/:id` | 更新角色 |
| DELETE | `/api/v1/system/roles/:id` | 删除角色 |
| GET | `/api/v1/system/roles/:id/menus` | 获取角色菜单 |
| PUT | `/api/v1/system/roles/:id/menus` | 更新角色菜单 |

## 5. JWT Claims 中的权限信息

```go
// pkg/auth/jwt.go
type Claims struct {
    UserID    int64  `json:"user_id"`
    Username  string `json:"username"`
    RoleKey   string `json:"role_key"`    // 角色标识 (如: admin, operator)
    RoleID    int64  `json:"role_id"`
    DataScope string `json:"data_scope"`  // 数据权限范围
    jwt.RegisteredClaims
}
```

## 6. 中间件中的权限校验

```go
// internal/middleware/jwt.go
func JWTAuth(jwtManager *auth.JWTManager) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. 从 Header 获取 Token
        token := c.GetHeader("Authorization")
        if token == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"code": 100100, "message": "请先登录"})
            c.Abort()
            return
        }
        token = strings.TrimPrefix(token, "Bearer ")
        token = strings.TrimSpace(token)

        // 2. 解析 Token
        claims, err := jwtManager.ParseToken(token)
        if err != nil {
            msg, code := "Token 无效", 100101
            if err == auth.ErrTokenExpired {
                msg, code = "Token 已过期", 100102
            }
            c.JSON(http.StatusUnauthorized, gin.H{"code": code, "message": msg})
            c.Abort()
            return
        }

        // 3. 注入用户信息到 Context
        c.Set("user_id", claims.UserID)
        c.Set("username", claims.Username)
        c.Set("role_key", claims.RoleKey)
        c.Set("role_id", claims.RoleID)
        c.Set("data_scope", claims.DataScope)
        c.Set("claims", claims)  // 同时注入完整 Claims

        c.Next()
    }
}
```

## 7. 数据权限过滤 (DataScope)

在业务查询中根据 DataScope 过滤数据:

```go
func (s *SomeService) GetList(ctx context.Context, userID uint64, dataScope string) ([]Data, error) {
    query := s.db.Model(&Data{})

    switch dataScope {
    case "1": // 全部数据
        // 不加过滤
    case "5": // 仅本人
        query = query.Where("created_by = ?", userID)
    case "3": // 本部门
        deptID := getDeptID(userID)
        query = query.Where("dept_id = ?", deptID)
    case "4": // 本部门及以下
        deptIDs := getDeptAndChildIDs(userID)
        query = query.Where("dept_id IN ?", deptIDs)
    }

    var list []Data
    query.Find(&list)
    return list, nil
}
```

## 8. 前端权限控制

### 8.1 权限存储

```typescript
// stores/auth.ts
export const useAuthStore = defineStore('auth', {
  state: () => ({
    permissions: [] as string[]
  }),

  actions: {
    hasPermission(perms: string | string[]): boolean {
      const required = Array.isArray(perms) ? perms : [perms]
      return required.some(p => this.permissions.includes(p))
    }
  }
})
```

### 8.2 权限指令

```typescript
// directives/permission.ts
export const permission = {
  mounted(el: HTMLElement, binding: DirectiveBinding) {
    const authStore = useAuthStore()
    const perms = binding.value

    if (!authStore.hasPermission(perms)) {
      el.parentNode?.removeChild(el)
    }
  }
}

// 使用
<button v-permission="'system:user:create'">添加用户</button>
```

### 8.3 路由权限

```typescript
// router/guards.ts
router.beforeEach((to, from, next) => {
  const authStore = useAuthStore()
  
  // 检查路由权限
  if (to.meta.permission) {
    if (!authStore.hasPermission(to.meta.permission as string)) {
      next('/403')
      return
    }
  }
  
  next()
})
```

## 9. 预置角色

| Key | 名称 | 说明 |
|-----|------|------|
| `admin` | 超级管理员 | 拥有所有权限 |
| `operator` | 运营人员 | 日常运营操作 |
| `viewer` | 观察者 | 只读权限 |

## 10. 最佳实践

1. **角色最小化原则**: 只赋予必要的权限
2. **禁止删除使用中的角色**: 有关联用户时不允许删除
3. **DataScope 优先**: 数据权限比功能权限更细粒度
4. **缓存权限**: 权限信息存入 JWT 避免频繁查库
5. **审计追踪**: 权限变更记录到操作日志
