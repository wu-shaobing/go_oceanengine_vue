---
alwaysApply: true
---

# TypeScript 规范

## 类型定义原则

### Interface vs Type

```typescript
// ✅ 使用 interface 定义对象结构
interface User {
  id: string;
  name: string;
  email: string;
}

// ✅ 使用 type 定义联合类型
type Status = 'pending' | 'active' | 'inactive';
type ID = string | number;

// ✅ 使用 type 定义交叉类型
type UserWithRole = User & { role: string };

// ✅ 使用 type 定义函数类型
type Validator = (value: string) => boolean;

// ✅ interface 可以声明合并
interface Window {
  myCustomProperty: string;
}

interface Window {
  anotherProperty: number;
}
```

### 类型文件组织

```typescript
// types/user.types.ts
export interface User {
  id: string;
  name: string;
  email: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateUserDto {
  name: string;
  email: string;
  password: string;
}

export interface UpdateUserDto {
  name?: string;
  email?: string;
}

export interface UserListParams {
  page: number;
  pageSize: number;
  keyword?: string;
  status?: UserStatus;
}

export interface UserListResponse {
  list: User[];
  total: number;
  page: number;
  pageSize: number;
}

export enum UserStatus {
  Active = 'active',
  Inactive = 'inactive',
  Pending = 'pending',
}

// 或使用 const assertion
export const USER_STATUS = {
  ACTIVE: 'active',
  INACTIVE: 'inactive',
  PENDING: 'pending',
} as const;

export type UserStatusType = typeof USER_STATUS[keyof typeof USER_STATUS];
```

## 严格模式配置

### tsconfig.json 必选配置

```json
{
  "compilerOptions": {
    "strict": true,                           // 启用所有严格类型检查
    "noImplicitAny": true,                    // 不允许隐式 any
    "strictNullChecks": true,                 // 严格的 null 检查
    "strictFunctionTypes": true,              // 严格的函数类型检查
    "strictBindCallApply": true,              // 严格的 bind/call/apply 检查
    "strictPropertyInitialization": true,     // 严格的属性初始化检查
    "noImplicitThis": true,                   // 不允许隐式 this
    "alwaysStrict": true,                     // 始终以严格模式解析
    
    "noUnusedLocals": true,                   // 检查未使用的局部变量
    "noUnusedParameters": true,               // 检查未使用的参数
    "noImplicitReturns": true,                // 检查函数的所有代码路径是否有返回值
    "noFallthroughCasesInSwitch": true,       // 检查 switch 的 fallthrough
    
    "esModuleInterop": true,                  // 启用 ESM 互操作
    "skipLibCheck": true,                     // 跳过库文件的类型检查
    "forceConsistentCasingInFileNames": true  // 强制文件名大小写一致
  }
}
```

## 泛型使用

### 基础泛型

```typescript
// ✅ 函数泛型
function identity<T>(value: T): T {
  return value;
}

// ✅ 接口泛型
interface ApiResponse<T> {
  code: number;
  message: string;
  data: T;
}

// ✅ 类泛型
class DataStore<T> {
  private data: T[] = [];
  
  add(item: T): void {
    this.data.push(item);
  }
  
  get(index: number): T | undefined {
    return this.data[index];
  }
}

// 使用
const userStore = new DataStore<User>();
userStore.add({ id: '1', name: 'John', email: 'john@example.com' });
```

### 泛型约束

```typescript
// ✅ 使用 extends 约束泛型
interface HasId {
  id: string;
}

function findById<T extends HasId>(items: T[], id: string): T | undefined {
  return items.find(item => item.id === id);
}

// ✅ 使用 keyof 约束
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const user: User = { id: '1', name: 'John', email: 'john@example.com' };
const name = getProperty(user, 'name'); // 类型为 string
```

### 高级泛型

```typescript
// ✅ 条件类型
type IsString<T> = T extends string ? true : false;
type A = IsString<string>; // true
type B = IsString<number>; // false

// ✅ 映射类型
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

type Partial<T> = {
  [P in keyof T]?: T[P];
};

type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

// 使用内置工具类型
type ReadonlyUser = Readonly<User>;
type PartialUser = Partial<User>;
type UserPreview = Pick<User, 'id' | 'name'>;

// ✅ 实用类型组合
type ApiSuccessResponse<T> = {
  success: true;
  data: T;
};

type ApiErrorResponse = {
  success: false;
  error: {
    code: string;
    message: string;
  };
};

type ApiResult<T> = ApiSuccessResponse<T> | ApiErrorResponse;

// 类型守卫
function isSuccess<T>(response: ApiResult<T>): response is ApiSuccessResponse<T> {
  return response.success === true;
}

// 使用
async function fetchUser(id: string): Promise<User> {
  const response = await fetch(`/api/users/${id}`);
  const result: ApiResult<User> = await response.json();
  
  if (isSuccess(result)) {
    return result.data; // TypeScript 知道这里是 User 类型
  }
  
  throw new Error(result.error.message);
}
```

## 实用工具类型

### 内置工具类型

```typescript
interface User {
  id: string;
  name: string;
  email: string;
  password: string;
  role: 'admin' | 'user';
  createdAt: Date;
}

// Partial - 所有属性可选
type PartialUser = Partial<User>;
// { id?: string; name?: string; ... }

// Required - 所有属性必选
type RequiredUser = Required<PartialUser>;

// Readonly - 所有属性只读
type ReadonlyUser = Readonly<User>;

// Pick - 选择部分属性
type UserPreview = Pick<User, 'id' | 'name' | 'email'>;
// { id: string; name: string; email: string }

// Omit - 排除部分属性
type UserWithoutPassword = Omit<User, 'password'>;
// { id: string; name: string; email: string; role: ...; createdAt: Date }

// Record - 创建映射类型
type UserMap = Record<string, User>;
// { [key: string]: User }

// Exclude - 从联合类型中排除
type Status = 'pending' | 'active' | 'inactive' | 'deleted';
type ActiveStatus = Exclude<Status, 'deleted'>;
// 'pending' | 'active' | 'inactive'

// Extract - 从联合类型中提取
type SuccessStatus = Extract<Status, 'active' | 'completed'>;
// 'active'

// NonNullable - 排除 null 和 undefined
type MaybeString = string | null | undefined;
type DefiniteString = NonNullable<MaybeString>;
// string

// ReturnType - 获取函数返回类型
function getUser() {
  return { id: '1', name: 'John' };
}
type UserReturn = ReturnType<typeof getUser>;
// { id: string; name: string }

// Parameters - 获取函数参数类型
function createUser(name: string, email: string) {}
type CreateUserParams = Parameters<typeof createUser>;
// [string, string]
```

### 自定义工具类型

```typescript
// ✅ 深度只读
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

// ✅ 深度可选
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

// ✅ 值为 Promise 的类型
type Promisify<T> = {
  [P in keyof T]: Promise<T[P]>;
};

// ✅ 提取 Promise 的值类型
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;
type Value = UnwrapPromise<Promise<string>>; // string

// ✅ 函数参数转可选
type OptionalParams<T extends (...args: any[]) => any> = 
  (...args: Partial<Parameters<T>>) => ReturnType<T>;
```

## 类型守卫和断言

### 类型守卫

```typescript
// ✅ typeof 类型守卫
function processValue(value: string | number) {
  if (typeof value === 'string') {
    return value.toUpperCase(); // TypeScript 知道这里是 string
  }
  return value.toFixed(2); // TypeScript 知道这里是 number
}

// ✅ instanceof 类型守卫
class Dog {
  bark() {}
}

class Cat {
  meow() {}
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark();
  } else {
    animal.meow();
  }
}

// ✅ in 类型守卫
interface Bird {
  fly(): void;
  layEggs(): void;
}

interface Fish {
  swim(): void;
  layEggs(): void;
}

function move(animal: Bird | Fish) {
  if ('fly' in animal) {
    animal.fly();
  } else {
    animal.swim();
  }
}

// ✅ 自定义类型守卫
function isUser(obj: unknown): obj is User {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'id' in obj &&
    'name' in obj &&
    'email' in obj
  );
}

function processData(data: unknown) {
  if (isUser(data)) {
    console.log(data.name); // TypeScript 知道这里是 User
  }
}
```

### 类型断言

```typescript
// ✅ as 断言（谨慎使用）
const userInput = document.getElementById('user-input') as HTMLInputElement;
userInput.value = 'Hello';

// ✅ 非空断言（确定不为 null/undefined 时使用）
function processUser(user: User | null) {
  // 如果确定 user 不为 null
  const name = user!.name;
}

// ❌ 避免双重断言
const value = 'hello' as unknown as number; // 不推荐

// ✅ 使用 const 断言
const colors = ['red', 'green', 'blue'] as const;
type Color = typeof colors[number]; // 'red' | 'green' | 'blue'

const config = {
  host: 'localhost',
  port: 3000,
} as const;
type Config = typeof config;
// { readonly host: 'localhost'; readonly port: 3000 }
```

## 禁止行为

```typescript
// ❌ 禁止使用 any
function processData(data: any) {
  return data;
}

// ✅ 使用 unknown 或具体类型
function processData(data: unknown) {
  if (typeof data === 'string') {
    return data.toUpperCase();
  }
  throw new Error('Invalid data type');
}

// ❌ 禁止空接口
interface EmptyInterface {}

// ✅ 使用 Record 或具体类型
type EmptyObject = Record<string, never>;

// ❌ 禁止使用 Function 类型
const callback: Function = () => {};

// ✅ 使用具体的函数签名
const callback: () => void = () => {};
const handler: (event: Event) => void = (event) => {};

// ❌ 禁止使用 Object 类型
function process(obj: Object) {}

// ✅ 使用具体类型或 Record
function process(obj: Record<string, unknown>) {}

// ❌ 禁止使用 @ts-ignore
// @ts-ignore
const value = someUntypedLibrary();

// ✅ 使用 @ts-expect-error 并说明原因
// @ts-expect-error - 等待第三方库更新类型定义
const value = someUntypedLibrary();
```

## 最佳实践

### 1. 优先使用接口组合而非继承

```typescript
// ✅ 好的方式：组合
interface Nameable {
  name: string;
}

interface Emailable {
  email: string;
}

interface User extends Nameable, Emailable {
  id: string;
}
```

### 2. 使用字面量类型提高类型安全

```typescript
// ✅ 使用字符串字面量联合类型
type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';

function request(url: string, method: HttpMethod) {
  // method 只能是指定的值
}
```

### 3. 善用类型推断

```typescript
// ✅ 利用类型推断，减少显式类型标注
const users = [
  { id: '1', name: 'John' },
  { id: '2', name: 'Jane' },
]; // TypeScript 自动推断为 Array<{ id: string; name: string }>

// ❌ 不必要的类型标注
const users: Array<{ id: string; name: string }> = [
  { id: '1', name: 'John' },
  { id: '2', name: 'Jane' },
];
```

### 4. 导出所有公共类型

```typescript
// ✅ 导出类型供其他模块使用
export interface User {
  id: string;
  name: string;
}

export type UserStatus = 'active' | 'inactive';

export interface UserService {
  getUser(id: string): Promise<User>;
  updateUser(id: string, data: Partial<User>): Promise<User>;
}
```

## 质量检查清单

- [ ] 所有函数都有明确的参数和返回值类型
- [ ] 没有使用 `any` 类型
- [ ] 没有使用 `@ts-ignore`
- [ ] 类型定义放在独立的 `.types.ts` 文件中
- [ ] 启用了 TypeScript 严格模式
- [ ] 使用了合适的工具类型（Partial, Pick, Omit 等）
- [ ] 复杂类型有注释说明
- [ ] 所有公共类型都已导出
